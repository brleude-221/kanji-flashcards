<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Kanji Flashcards</title>

<style>
body{
  font-family:sans-serif;
  display:flex;
  gap:30px;
  padding:20px;
}

#main{
  width:100%;
  text-align:center;
}

#side{
  width:40%;
  border-left:1px solid #ccc;
  padding-left:15px;
  max-height:80vh;
  overflow-y:auto;
}

.card{
  font-size:40px;
  margin:40px auto;
  cursor:pointer;
  user-select:none;
}

.meaning{
  font-size:20px;
  color:#444;
  margin-top:10px;
  min-height:24px;
  cursor:pointer;
}

button,select{
  font-size:16px;
  margin:5px;
  text-transform: lowercase;
}

#saveContainer{
  text-align:center;   /* ★ centers the save button */
  margin-top:10px;
}

table{
  width:100%;
  border-collapse:collapse;
  font-size:14px;
}

th,td{
  border:1px solid #ccc;
  padding:4px;
}

hr{ margin:20px 0; }
</style>
</head>

<body>

<div id="main">

<h2>Kanji Flashcards</h2>

<input type="file" id="fileInput"><br>
<hr>

Mode:
<select id="modeSelect">
  <option value="k2r">kanji → reading</option>
  <option value="r2k">reading → kanji</option>
</select>

<div>
Total: <span id="total">0</span> |
Round: <span id="seen">0</span> |
Words Left: <span id="left">0</span>
</div>

<div class="card" id="card" onclick="handleCardClick()">
Load a CSV
</div>

<button onclick="toggleMeaning()">meaning</button>
<div class="meaning" id="meaning" onclick="meaningClick()"></div>

<button onclick="know()">know</button>
<button onclick="dontKnow()">don't know</button>

<button onclick="undo()">undo</button>

<hr>

<button onclick="toggleSide()">hide unknown</button>

</div>

<div id="side">
<h3 id="unknownTitle">Unknown</h3>
<table>
<thead>
<tr>
<th>Kanji</th>
<th>Reading</th>
<th>Meaning</th>
</tr>
</thead>
<tbody id="unknownTable"></tbody>
</table>

<div id="saveContainer">
  <button onclick="saveUnknown()">save</button>
</div>

</div>

<script>

let allCards=[];
let newCards=[];
let roundQueue=[];
let unknownMap=new Map();

let index=0;
let meaningVisible=false;
let showingFront=true;

let historyStack=[];
let originalFileName="";   // ★ for saved file name

/* ---------- Load CSV ---------- */

fileInput.addEventListener("change",e=>{
  const file = e.target.files[0];
  originalFileName = file.name.replace(/\.[^/.]+$/, "");  // remove extension

  const reader=new FileReader();
  reader.onload=()=>{
    const rows=reader.result.trim().split("\n").map(r=>r.split(","));
    allCards=rows.map(r=>({data:r,seen:0}));
    resetSession();
    show();
  };
  reader.readAsText(file);
});

/* ---------- Mode Reset ---------- */

modeSelect.addEventListener("change",()=>{
  resetSession();
  updateUnknownTitle();
  show();
});

/* ---------- Reset ---------- */

function resetSession(){
  newCards=[...allCards];
  shuffle(newCards);
  roundQueue=[];
  unknownMap.clear();
  historyStack=[];
  index=0;
  startNextRound();
  renderUnknownTable();
}

/* ---------- Rounds ---------- */

function startNextRound(){
  if(newCards.length>0){
    roundQueue=[...newCards];
    newCards=[];
  }else{
    roundQueue=[...unknownMap.values()];
  }
  shuffle(roundQueue);
  index=0;
}

/* ---------- Display ---------- */

function show(){
  if(roundQueue.length===0){
    card.textContent=":)";
    meaning.textContent="";
    total.textContent=0;
    left.textContent=0;
    renderUnknownTable();
    return;
  }

  const c=roundQueue[index];
  c.seen++;

  showingFront=true;
  meaning.textContent="";
  meaningVisible=false;

  updateCardText();
  updateUnknownTitle();

  total.textContent=roundQueue.length;
  seen.textContent=c.seen-1;
  left.textContent=roundQueue.length-index;

  renderUnknownTable();
}

/* ---------- Card Logic ---------- */

function updateCardText(){
  const c=roundQueue[index];

  if(modeSelect.value==="k2r"){
    card.textContent = showingFront ? c.data[0] : c.data[1];
  }else{
    card.textContent = showingFront ? c.data[1] : c.data[0];
  }
}

function handleCardClick(){
  if(roundQueue.length===0){
    // Finished mode: flip between :) and (:
    card.textContent = card.textContent === ":)" ? "(:"
                                                 : ":)";
    return;
  }
  showingFront=!showingFront;
  updateCardText();
}

/* ---------- Meaning ---------- */

function toggleMeaning(){
  if(roundQueue.length===0){
    meaning.textContent="you did good!";
    return;
  }

  const c=roundQueue[index];

  if(!meaningVisible){
    meaning.textContent=c.data[2];
    meaningVisible=true;
  }else{
    meaning.textContent="";
    meaningVisible=false;
  }
}

function meaningClick(){
  if(roundQueue.length===0){
    meaning.textContent="you did good!";
  }
}

/* ---------- Buttons ---------- */

function know(){
  if(roundQueue.length===0) return;
  const c=roundQueue[index];

  historyStack.push({card:c, action:"know", wasUnknown:unknownMap.has(c.data.join(","))});

  unknownMap.delete(c.data.join(","));
  nextCard();
}

function dontKnow(){
  if(roundQueue.length===0) return;
  const c=roundQueue[index];

  historyStack.push({card:c, action:"dontKnow"});

  unknownMap.set(c.data.join(","),c);
  nextCard();
}

/* ---------- Undo ---------- */

function undo(){
  if(historyStack.length===0) return;

  index = Math.max(0, index - 1);

  const last = historyStack.pop();
  const c = last.card;
  const key = c.data.join(",");

  if(last.action==="know"){
    if(last.wasUnknown){
      unknownMap.set(key,c);
    }
  }

  if(last.action==="dontKnow"){
    unknownMap.delete(key);
  }

  show();
}

/* ---------- Navigation ---------- */

function nextCard(){
  index++;
  if(index>=roundQueue.length){
    startNextRound();
  }
  show();
}

/* ---------- Sidebar ---------- */

function toggleSide(){
  if(side.style.display==="none"){
    side.style.display="block";
    event.target.textContent="hide unknown";
  }else{
    side.style.display="none";
    event.target.textContent="show unknown";
  }
  renderUnknownTable();
}

function updateUnknownTitle(){
  if(modeSelect.value==="k2r"){
    unknownTitle.textContent="Unknown Reading";
  }else{
    unknownTitle.textContent="Unknown Kanji";
  }
}

function renderUnknownTable(){
  unknownTable.innerHTML="";

  if(unknownMap.size===0){
    return;
  }

  unknownMap.forEach(c=>{
    const tr=document.createElement("tr");
    c.data.forEach(v=>{
      const td=document.createElement("td");
      td.textContent=v;
      tr.appendChild(td);
    });
    unknownTable.appendChild(tr);
  });
}

/* ---------- Save Unknown CSV ---------- */

function saveUnknown(){
  if(unknownMap.size===0){
    alert("No unknown words to save.");
    return;
  }

  let csv = "";
  unknownMap.forEach(c=>{
    csv += c.data.join(",") + "\n";
  });

  const blob = new Blob([csv],{type:"text/csv"});
  const url = URL.createObjectURL(blob);
  const a = document.createElement("a");

  // ★ file naming rule
  let suffix = modeSelect.value === "k2r"
    ? "_unknown_reading"
    : "_unknown_kanji";

  a.href = url;
  a.download = originalFileName + suffix + ".csv";
  a.click();

  URL.revokeObjectURL(url);
}

/* ---------- Shuffle ---------- */

function shuffle(a){
  for(let i=a.length-1;i>0;i--){
    const j=Math.floor(Math.random()*(i+1));
    [a[i],a[j]]=[a[j],a[i]];
  }
}

</script>

</body>
</html>

